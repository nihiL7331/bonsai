use crate::error::CustomError;
use std::fs;
use std::path::Path;
use texture_packer::TexturePacker;

enum AssetSearchMode<'a> {
    ByExtension(&'a str),
    Directories,
}

//sprite
const SPRITE_OUTPUT_DIR: &str = "source/types/game/generated_sprite.odin";
//font
const FONT_SRC_DIR: &str = "assets/fonts";
const FONT_OUT_DIR: &str = "source/types/game/generated_font.odin";
//audio
const AUDIO_SRC_DIR: &str = "assets/audio";
const AUDIO_OUT_DIR: &str = "source/types/game/generated_audio.odin";
//scene
const SCENE_REG_OUT_DIR: &str = "source/game/scenes/generated_registry.odin";
const SCENE_SRC_DIR: &str = "source/game/scenes";
const SCENE_OUT_DIR: &str = "source/types/game/generated_scene.odin";

//this is separated from generate_asset_metadata, since there's a lot of "custom" logic here
pub fn generate_sprite_metadata(
    packer: &TexturePacker<image::RgbaImage, String>,
    width: u32,
    height: u32,
) -> Result<(), CustomError> {
    let mut odin_code = String::new();

    odin_code.push_str("package game_types\n\n");
    odin_code.push_str("import \"../gmath\"\n\n");
    odin_code.push_str("// NOTE: Don't edit. Generated by CLI.\n");

    odin_code.push_str("SpriteData :: struct {\n");
    odin_code.push_str("\tuv:           gmath.Vec4,\n");
    odin_code.push_str("\tsize:         gmath.Vec2,\n");
    odin_code.push_str("}\n\n");

    odin_code.push_str("SpriteName :: enum {\n");
    odin_code.push_str("\tnil,\n");
    for (key, _) in packer.get_frames() {
        let clean_key = key.replace("-", "_").replace(" ", "_");
        odin_code.push_str(&format!("\t{},\n", clean_key));
    }
    odin_code.push_str("}\n\n");

    odin_code.push_str("getSpriteData :: proc(sprite: SpriteName) -> SpriteData {\n");
    odin_code.push_str("\tswitch sprite {\n");
    let w = width as f32;
    let h = height as f32;
    odin_code.push_str("\tcase .nil: return { gmath.Vec4{0, 0, 0, 0}, gmath.Vec2{0, 0} }\n");
    for (key, frame) in packer.get_frames() {
        let clean_key = key.replace("-", "_").replace(" ", "_");

        let u0 = frame.frame.x as f32 / w;
        let v0 = frame.frame.y as f32 / h;
        let u1 = (frame.frame.x + frame.frame.w) as f32 / w;
        let v1 = (frame.frame.y + frame.frame.h) as f32 / h;

        let px_w = frame.frame.w as f32;
        let px_h = frame.frame.h as f32;

        odin_code.push_str(&format!(
            "\tcase .{}: return {{ gmath.Vec4{{ {:.6}, {:.6}, {:.6}, {:.6} }}, gmath.Vec2{{ {:.1}, {:.1} }} }}\n",
            clean_key, u0, v0, u1, v1, px_w, px_h
        ));
    }

    odin_code.push_str("\t}\n");
    odin_code.push_str("\treturn {gmath.Vec4{0, 0, 0, 0}, gmath.Vec2{0, 0} }\n");
    odin_code.push_str("}\n");

    let output_path = Path::new(SPRITE_OUTPUT_DIR);

    fs::create_dir_all(output_path.parent().unwrap())?;
    fs::write(output_path, odin_code)?;

    Ok(())
}

//like above, too custom to abstract out
fn generate_scene_registry_metadata(scene_src: &str, scene_out: &str) -> Result<(), CustomError> {
    let scene_dir = Path::new(scene_src);
    let registry_file = Path::new(scene_out);

    let mut entries = vec![];
    if scene_dir.exists() {
        for entry in fs::read_dir(scene_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_dir() {
                if let (Some(stem_os), Some(filename_os)) = (path.file_stem(), path.file_name()) {
                    if let (Some(stem), Some(filename)) = (stem_os.to_str(), filename_os.to_str()) {
                        let clean_stem = stem.replace("-", "_").replace(" ", "_");
                        entries.push((clean_stem, filename.to_string()));
                    }
                }
            }
        }
    }

    let mut odin_code = String::new();

    odin_code.push_str("// NOTE: Machine generated by bonsai CLI\n");
    odin_code.push_str("package scenes\n\n");
    odin_code.push_str("import \"../../core/scene\"\n");
    odin_code.push_str("import \"../../types/game\"\n");
    for (name, _) in &entries {
        odin_code.push_str(&format!("import \"{name}\"\n"));
    }
    odin_code.push_str("\n");
    for (name, _) in &entries {
        odin_code.push_str(&format!("@(private)\n_{name}Data: {name}.Data\n"));
    }
    odin_code.push_str("\ninitRegistry :: proc() {\n");
    //yeah
    for (name, _) in &entries {
        odin_code.push_str(&format!("\tscene.register(\n\t\tgame.SceneName.{name},\n\t\tgame.Scene{{\n\t\t\tdata=&_{name}Data,\n\t\t\tinit={name}.init,\n\t\t\tupdate={name}.update,\n\t\t\tdraw={name}.draw,\n\t\t\texit={name}.exit,\n\t\t}},\n\t)\n"))
    }
    odin_code.push_str("}");

    if let Some(parent) = registry_file.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(registry_file, odin_code)?;

    Ok(())
}

pub fn generate_assets() -> Result<(), CustomError> {
    generate_asset_metadata(
        FONT_SRC_DIR,
        FONT_OUT_DIR,
        AssetSearchMode::ByExtension("ttf"),
        "Font",
    )?;
    generate_asset_metadata(
        AUDIO_SRC_DIR,
        AUDIO_OUT_DIR,
        AssetSearchMode::ByExtension("wav"),
        "Audio",
    )?;
    generate_asset_metadata(
        SCENE_SRC_DIR,
        SCENE_OUT_DIR,
        AssetSearchMode::Directories,
        "Scene",
    )?;
    generate_scene_registry_metadata(SCENE_SRC_DIR, SCENE_REG_OUT_DIR)?;
    Ok(())
}

fn generate_asset_metadata(
    asset_src: &str,
    asset_out: &str,
    mode: AssetSearchMode,
    enum_name: &str,
) -> Result<(), CustomError> {
    let asset_dir = Path::new(asset_src);
    let output_file = Path::new(asset_out);

    let mut entries = vec![];
    if asset_dir.exists() {
        for entry in fs::read_dir(asset_dir)? {
            let entry = entry?;
            let path = entry.path();

            let is_match = match mode {
                AssetSearchMode::ByExtension(ext) => {
                    path.is_file() && path.extension().and_then(|s| s.to_str()) == Some(ext)
                }
                AssetSearchMode::Directories => path.is_dir(),
            };

            if is_match {
                if let (Some(stem_os), Some(filename_os)) = (path.file_stem(), path.file_name()) {
                    if let (Some(stem), Some(filename)) = (stem_os.to_str(), filename_os.to_str()) {
                        let clean_stem = stem.replace("-", "_").replace(" ", "_");
                        entries.push((clean_stem, filename.to_string()));
                    }
                }
            }
        }
    }

    let mut odin_code = String::new();

    odin_code.push_str("// NOTE: Machine generated by bonsai CLI\n");
    odin_code.push_str("package game_types\n\n");

    odin_code.push_str(&format!("{}Name :: enum {{\n", enum_name));
    odin_code.push_str("\tnil,\n");
    for (name, _) in &entries {
        odin_code.push_str(&format!("\t{}, \n", name));
    }
    odin_code.push_str("}\n\n");

    if let AssetSearchMode::ByExtension(_) = mode {
        //map for gen
        odin_code.push_str(&format!(
            "{}Filename := [{}Name]string {{\n",
            enum_name.to_lowercase(),
            enum_name
        ));
        odin_code.push_str("\t.nil = \"\",\n");
        for (name, file) in &entries {
            odin_code.push_str(&format!("\t.{} = \"{}\",\n", name, file));
        }
        odin_code.push_str("}\n");
    }

    if let Some(parent) = output_file.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(output_file, odin_code)?;

    Ok(())
}
