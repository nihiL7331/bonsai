use crate::error::CustomError;
use std::collections::HashSet;
use std::fs;
use std::path::Path;
use texture_packer::TexturePacker;

enum AssetSearchMode<'a> {
    ByExtension(&'a str),
    Directories,
}

//sprite
const SPRITE_OUTPUT_DIR: &str = "bonsai/generated/sprite.odin";
//font
const FONT_SRC_DIR: &str = "assets/fonts";
const FONT_OUT_DIR: &str = "bonsai/generated/font.odin";
const ADDITIONAL_FONT_ENUM: &str = "PixelCode";
//HACK: go backwards  to leave assets/fonts since filenames are relative to that path
const ADDITIONAL_FONT_FILENAME: &str = "../../bonsai/core/ui/PixelCode.ttf";
//audio
const AUDIO_SRC_DIR: &str = "assets/audio";
const AUDIO_OUT_DIR: &str = "bonsai/generated/audio.odin";
//scene
const SCENE_REG_OUT_DIR: &str = "source/game/scenes/generated_registry.odin";
const SCENE_SRC_DIR: &str = "source/game/scenes";
const SCENE_OUT_DIR: &str = "bonsai/generated/scene.odin";

fn clean_key_suffix(mut clean_key: String) -> Result<String, CustomError> {
    if let Some(last_underscore) = clean_key.rfind('_') {
        let suffix = &clean_key[last_underscore + 1..];
        if let Some(x_idx) = suffix.find('x') {
            let left = &suffix[..x_idx];
            let right = &suffix[x_idx + 1..];
            if left.parse::<i32>().is_ok() && right.parse::<i32>().is_ok() {
                clean_key.truncate(last_underscore);
            }
        }
    }
    Ok(clean_key)
}

//this is separated from generate_asset_metadata, since there's a lot of "custom" logic here
pub fn generate_sprite_metadata(
    packer: &TexturePacker<image::RgbaImage, String>,
    width: u32,
    height: u32,
    extruded_sprites: &HashSet<String>,
) -> Result<(), CustomError> {
    let mut odin_code = String::new();

    odin_code.push_str("// NOTE: Machine generated by bonsai CLI.\n");
    odin_code.push_str("package generated\n\n");
    odin_code.push_str("import \"bonsai:core/gmath\"\n\n");

    odin_code.push_str("SpriteData :: struct {\n");
    odin_code.push_str("\tuv:           gmath.Vector4,\n");
    odin_code.push_str("\tsize:         gmath.Vector2,\n");
    odin_code.push_str("}\n\n");

    odin_code.push_str("SpriteName :: enum {\n");
    odin_code.push_str("\tnil,\n");
    for (key, _) in packer.get_frames() {
        let mut clean_key = key.replace("-", "_").replace(" ", "_");
        clean_key = clean_key_suffix(clean_key)?;
        odin_code.push_str(&format!("\t{},\n", clean_key));
    }
    odin_code.push_str("}\n\n");

    odin_code.push_str("getSpriteData :: proc(sprite: SpriteName) -> SpriteData {\n");
    odin_code.push_str("\tswitch sprite {\n");
    odin_code.push_str("\tcase .nil: return { gmath.Vector4{0, 0, 0, 0}, gmath.Vector2{0, 0} }\n");
    for (key, frame) in packer.get_frames() {
        let mut clean_key = key.replace("-", "_").replace(" ", "_");
        clean_key = clean_key_suffix(clean_key)?;

        let mut x = frame.frame.x;
        let mut y = frame.frame.y;
        let mut w = frame.frame.w;
        let mut h = frame.frame.h;

        if extruded_sprites.contains(key) {
            x += 1;
            y += 1;
            w -= 2;
            h -= 2;
        }

        let u0 = x as f32 / width as f32;
        let v0 = y as f32 / height as f32;
        let u1 = (x + w) as f32 / width as f32;
        let v1 = (y + h) as f32 / height as f32;

        odin_code.push_str(&format!(
            "\tcase .{}: return {{ gmath.Vector4{{ {:.6}, {:.6}, {:.6}, {:.6} }}, gmath.Vector2{{ {:.1}, {:.1} }} }}\n",
            clean_key, u0, v0, u1, v1, w, h
        ));
    }

    odin_code.push_str("\t}\n");
    odin_code.push_str("\treturn { gmath.Vector4{0, 0, 0, 0}, gmath.Vector2{0, 0} }\n");
    odin_code.push_str("}\n\n");

    odin_code.push_str("getFrameCount :: proc(sprite: SpriteName) -> int {\n");
    odin_code.push_str("\t#partial switch sprite {\n");

    for (key, _) in packer.get_frames() {
        let normalized_key = key.replace("-", "_").replace(" ", "_");
        let enum_name = clean_key_suffix(normalized_key.clone())?;
        if let Some(last_underscore_index) = normalized_key.rfind('_') {
            let suffix = &normalized_key[last_underscore_index + 1..];

            if let Some(x_char_index) = suffix.find('x') {
                let frames_str = &suffix[..x_char_index];
                let rows_str = &suffix[x_char_index + 1..];

                if let (Ok(frames), Ok(_rows)) =
                    (frames_str.parse::<i32>(), rows_str.parse::<i32>())
                {
                    odin_code.push_str(&format!("\tcase .{}: return {}\n", enum_name, frames));
                }
            }
        }
    }

    odin_code.push_str("\t}\n");
    odin_code.push_str("\treturn 1\n");
    odin_code.push_str("}\n");

    let output_path = Path::new(SPRITE_OUTPUT_DIR);

    fs::create_dir_all(output_path.parent().unwrap())?;
    fs::write(output_path, odin_code)?;

    Ok(())
}

//like above, too custom to abstract out
fn generate_scene_registry_metadata(scene_src: &str, scene_out: &str) -> Result<(), CustomError> {
    let scene_dir = Path::new(scene_src);
    let registry_file = Path::new(scene_out);

    let mut entries = vec![];
    if scene_dir.exists() {
        for entry in fs::read_dir(scene_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_dir() {
                if let (Some(stem_os), Some(filename_os)) = (path.file_stem(), path.file_name()) {
                    if let (Some(stem), Some(filename)) = (stem_os.to_str(), filename_os.to_str()) {
                        let clean_stem = stem.replace("-", "_").replace(" ", "_");
                        entries.push((clean_stem, filename.to_string()));
                    }
                }
            }
        }
    }

    let mut odin_code = String::new();

    odin_code.push_str("// NOTE: Machine generated by bonsai CLI.\n");
    odin_code.push_str("package scenes\n\n");
    odin_code.push_str("import \"bonsai:core/scene\"\n");
    odin_code.push_str("import \"bonsai:core/scene/type\"\n");
    odin_code.push_str("import \"bonsai:generated\"");
    odin_code.push_str("\n");
    odin_code.push_str("_ :: scene\n");
    odin_code.push_str("_ :: generated\n");
    odin_code.push_str("\n");
    for (name, _) in &entries {
        odin_code.push_str(&format!("import \"{name}\"\n"));
    }
    odin_code.push_str("\n");
    for (name, _) in &entries {
        odin_code.push_str(&format!(
            "@(private = \"file\")\n_{name}Data: {name}.Data\n"
        ));
    }
    odin_code.push_str("\ninitRegistry :: proc() {\n");
    //yeah
    for (name, _) in &entries {
        odin_code.push_str(&format!("\tscene.register(\n\t\tgenerated.SceneName.{name},\n\t\ttype.Scene{{\n\t\t\tdata=&_{name}Data,\n\t\t\tinit={name}.init,\n\t\t\tupdate={name}.update,\n\t\t\tdraw={name}.draw,\n\t\t\texit={name}.exit,\n\t\t}},\n\t)\n"))
    }
    odin_code.push_str("}");

    if let Some(parent) = registry_file.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(registry_file, odin_code)?;

    Ok(())
}

pub fn generate_assets() -> Result<(), CustomError> {
    generate_asset_metadata(
        FONT_SRC_DIR,
        FONT_OUT_DIR,
        ADDITIONAL_FONT_ENUM,
        ADDITIONAL_FONT_FILENAME,
        AssetSearchMode::ByExtension("ttf"),
        "Font",
    )?;
    generate_asset_metadata(
        AUDIO_SRC_DIR,
        AUDIO_OUT_DIR,
        "",
        "",
        AssetSearchMode::ByExtension("wav"),
        "Audio",
    )?;
    generate_asset_metadata(
        SCENE_SRC_DIR,
        SCENE_OUT_DIR,
        "",
        "",
        AssetSearchMode::Directories,
        "Scene",
    )?;
    generate_scene_registry_metadata(SCENE_SRC_DIR, SCENE_REG_OUT_DIR)?;
    Ok(())
}

fn generate_asset_metadata(
    asset_src: &str,
    asset_out: &str,
    additional_asset_enum: &str,
    additional_asset_filename: &str,
    mode: AssetSearchMode,
    enum_name: &str,
) -> Result<(), CustomError> {
    let asset_dir = Path::new(asset_src);
    let output_file = Path::new(asset_out);

    let mut entries = vec![];
    if asset_dir.exists() {
        for entry in fs::read_dir(asset_dir)? {
            let entry = entry?;
            let path = entry.path();

            let is_match = match mode {
                AssetSearchMode::ByExtension(ext) => {
                    path.is_file() && path.extension().and_then(|s| s.to_str()) == Some(ext)
                }
                AssetSearchMode::Directories => path.is_dir(),
            };

            if is_match {
                if let (Some(stem_os), Some(filename_os)) = (path.file_stem(), path.file_name()) {
                    if let (Some(stem), Some(filename)) = (stem_os.to_str(), filename_os.to_str()) {
                        let clean_stem = stem.replace("-", "_").replace(" ", "_");
                        entries.push((clean_stem, filename.to_string()));
                    }
                }
            }
        }
    }

    let mut odin_code = String::new();

    odin_code.push_str("// NOTE: Machine generated by bonsai CLI\n");
    odin_code.push_str("package generated\n\n");

    odin_code.push_str(&format!("{}Name :: enum {{\n", enum_name));
    odin_code.push_str("\tnil,\n");
    if additional_asset_enum != "" && additional_asset_filename != "" {
        odin_code.push_str(&format!("\t{}, \n", additional_asset_enum));
    }
    for (name, _) in &entries {
        odin_code.push_str(&format!("\t{}, \n", name));
    }
    odin_code.push_str("}\n\n");

    if let AssetSearchMode::ByExtension(_) = mode {
        //map for gen
        odin_code.push_str(&format!(
            "{}Filename := [{}Name]string {{\n",
            enum_name.to_lowercase(),
            enum_name
        ));
        odin_code.push_str("\t.nil = \"\",\n");
        if additional_asset_enum != "" && additional_asset_filename != "" {
            odin_code.push_str(&format!(
                "\t.{} = \"{}\", \n",
                additional_asset_enum, additional_asset_filename
            ));
        }
        for (name, file) in &entries {
            odin_code.push_str(&format!("\t.{} = \"{}\",\n", name, file));
        }
        odin_code.push_str("}\n");
    }

    if let Some(parent) = output_file.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(output_file, odin_code)?;

    Ok(())
}
